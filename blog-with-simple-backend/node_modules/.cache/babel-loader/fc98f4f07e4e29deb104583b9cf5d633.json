{"ast":null,"code":"import { useReducer as e, useCallback as t } from \"react\";\n\nvar n = {\n  past: [],\n  present: null,\n  future: []\n},\n    r = function r(e, t) {\n  var n = e.past,\n      r = e.present,\n      u = e.future;\n\n  switch (t.type) {\n    case \"UNDO\":\n      var s = n[n.length - 1];\n      return {\n        past: n.slice(0, n.length - 1),\n        present: s,\n        future: [r].concat(u)\n      };\n\n    case \"REDO\":\n      var a = u[0],\n          c = u.slice(1);\n      return {\n        past: n.concat([r]),\n        present: a,\n        future: c\n      };\n\n    case \"SET\":\n      var p = t.newPresent;\n      return p === r ? e : {\n        past: n.concat([r]),\n        present: p,\n        future: []\n      };\n\n    case \"RESET\":\n      return {\n        past: [],\n        present: t.newPresent,\n        future: []\n      };\n  }\n};\n\nexport default function (u) {\n  var s = e(r, Object.assign({}, n, {\n    present: u\n  })),\n      a = s[0],\n      c = s[1],\n      p = 0 !== a.past.length,\n      o = 0 !== a.future.length,\n      f = t(function () {\n    p && c({\n      type: \"UNDO\"\n    });\n  }, [p]),\n      i = t(function () {\n    o && c({\n      type: \"REDO\"\n    });\n  }, [o]);\n  return [a, {\n    set: t(function (e) {\n      return c({\n        type: \"SET\",\n        newPresent: e\n      });\n    }, []),\n    reset: t(function (e) {\n      return c({\n        type: \"RESET\",\n        newPresent: e\n      });\n    }, []),\n    undo: f,\n    redo: i,\n    canUndo: p,\n    canRedo: o\n  }];\n}","map":null,"metadata":{},"sourceType":"module"}