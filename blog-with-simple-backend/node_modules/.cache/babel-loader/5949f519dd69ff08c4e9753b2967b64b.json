{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { createURLDescriptor, joinPaths, modifyTrailingSlash } from 'navi';\nimport { HashScrollContext, scrollToHash } from './HashScroll';\nimport { NaviContext } from './NaviContext';\n\nfunction isExternalHref(href) {\n  // If this is an external link, return undefined so that the native\n  // response will be used.\n  return !href || typeof href === 'string' && (href.indexOf('://') !== -1 || href.indexOf('mailto:') === 0);\n}\n\nfunction getLinkURL(href, routeURL) {\n  if (!isExternalHref(href)) {\n    // Resolve relative to the current \"directory\"\n    if (routeURL && typeof href === 'string') {\n      href = href[0] === '/' ? href : joinPaths('/', routeURL.pathname, href);\n    }\n\n    return createURLDescriptor(href);\n  }\n}\n/**\n * Returns a boolean that indicates whether the user is currently\n * viewing the specified href.\n * @param href\n * @param options.exact If false, will match any URL underneath this href\n * @param options.loading If true, will match even if the route is currently loading\n */\n\n\nexport var useActive = function useActive(href, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.exact,\n      exact = _c === void 0 ? true : _c,\n      _d = _b.loading,\n      loading = _d === void 0 ? false : _d;\n\n  var context = React.useContext(NaviContext);\n  var route = loading ? context.busyRoute || context.steadyRoute : context.steadyRoute || context.busyRoute;\n  var routeURL = route && route.url;\n  var linkURL = getLinkURL(href, routeURL);\n  return !!(linkURL && routeURL && (exact ? linkURL.pathname === routeURL.pathname : modifyTrailingSlash(routeURL.pathname, 'add').indexOf(linkURL.pathname) === 0));\n};\nexport var useLinkProps = function useLinkProps(_a) {\n  var disabled = _a.disabled,\n      hashScrollBehavior = _a.hashScrollBehavior,\n      href = _a.href,\n      prefetch = _a.prefetch,\n      state = _a.state,\n      onClick = _a.onClick,\n      onMouseEnter = _a.onMouseEnter;\n\n  var _b, _c;\n\n  if (prefetch && state) {\n    prefetch = false;\n\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\"Warning: A <Link> component received both \\\"prefetch\\\" and \\\"state\\\" \" + \"props, but links with state cannot be prefetched. Skipping prefetch.\");\n    }\n  }\n\n  if (prefetch === true) {\n    prefetch = 'mount';\n\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\"Warning: A <Link> component received a \\\"prefetch\\\" value of \\\"true\\\". \" + \"This value is no longer supported - please set it to \\\"mount\\\" instead.\");\n    }\n  } // Prefetch on hover by default.\n\n\n  if (prefetch === undefined) {\n    prefetch = 'hover';\n  }\n\n  var hashScrollBehaviorFromContext = React.useContext(HashScrollContext);\n  var context = React.useContext(NaviContext);\n  var navigation = context.navigation;\n\n  if (hashScrollBehavior === undefined) {\n    hashScrollBehavior = hashScrollBehaviorFromContext;\n  }\n\n  var route = context.steadyRoute || context.busyRoute;\n  var routeURL = React.useMemo(function () {\n    return route && route.url;\n  }, [(_b = route) === null || _b === void 0 ? void 0 : _b.url.href]);\n  var linkURL = getLinkURL(href, routeURL);\n\n  if (!isExternalHref(href)) {\n    var resolvedHref = href; // Resolve relative to the current \"directory\"\n\n    if (routeURL && typeof href === 'string') {\n      resolvedHref = href[0] === '/' ? href : joinPaths('/', routeURL.pathname, href);\n    }\n\n    linkURL = createURLDescriptor(resolvedHref);\n  } // We need a URL descriptor that stays referentially equal so that we don't\n  // trigger prefetches more than we'd like.\n\n\n  var memoizedLinkURL = React.useMemo(function () {\n    return linkURL;\n  }, [(_c = linkURL) === null || _c === void 0 ? void 0 : _c.href]);\n  var doPrefetch = React.useMemo(function () {\n    var hasPrefetched = false;\n    return function () {\n      if (!hasPrefetched && memoizedLinkURL && memoizedLinkURL.pathname && navigation) {\n        hasPrefetched = true;\n        navigation.prefetch(memoizedLinkURL).catch(function (e) {\n          console.warn(\"A <Link> tried to prefetch \\\"\" + memoizedLinkURL.pathname + \"\\\", but the \" + \"router was unable to fetch this path.\");\n        });\n      }\n    };\n  }, [memoizedLinkURL, navigation]); // Prefetch on mount if required, or if `prefetch` becomes `true`.\n\n  React.useEffect(function () {\n    if (prefetch === 'mount') {\n      doPrefetch();\n    }\n  }, [prefetch, doPrefetch]);\n  var handleMouseEnter = React.useCallback(function (event) {\n    if (prefetch === 'hover') {\n      if (onMouseEnter) {\n        onMouseEnter(event);\n      }\n\n      if (disabled) {\n        event.preventDefault();\n        return;\n      }\n\n      if (!event.defaultPrevented) {\n        doPrefetch();\n      }\n    }\n  }, [disabled, doPrefetch, onMouseEnter, prefetch]);\n  var handleClick = React.useCallback(function (event) {\n    // Let the browser handle the event directly if:\n    // - The user used the middle/right mouse button\n    // - The user was holding a modifier key\n    // - A `target` property is set (which may cause the browser to open the\n    //   link in another tab)\n    if (event.button === 0 && !(event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)) {\n      if (disabled) {\n        event.preventDefault();\n        return;\n      }\n\n      if (onClick) {\n        onClick(event);\n      } // Sanity check\n\n\n      if (!routeURL) {\n        return;\n      }\n\n      if (!event.defaultPrevented && linkURL) {\n        event.preventDefault();\n        var isSamePathname = modifyTrailingSlash(linkURL.pathname, 'remove') === modifyTrailingSlash(routeURL.pathname, 'remove');\n        navigation.navigate(linkURL, state ? {\n          state: state\n        } : undefined);\n\n        if ((isSamePathname || linkURL.pathname === '') && linkURL.hash === routeURL.hash && linkURL.hash) {\n          scrollToHash(routeURL.hash, hashScrollBehavior);\n        }\n      }\n    }\n  }, [disabled, onClick, linkURL && linkURL.href, routeURL && routeURL.href]);\n  return {\n    onClick: handleClick,\n    onMouseEnter: handleMouseEnter,\n    href: linkURL ? linkURL.href : href\n  };\n}; // Need to include this type definition, as the automatically generated one\n// is incompatible with some versions of the react typings.\n\nexport var Link = React.forwardRef(function (props, anchorRef) {\n  var active = props.active,\n      _a = props.activeClassName,\n      activeClassName = _a === void 0 ? '' : _a,\n      _b = props.activeStyle,\n      activeStyle = _b === void 0 ? {} : _b,\n      _c = props.className,\n      className = _c === void 0 ? '' : _c,\n      disabled = props.disabled,\n      exact = props.exact,\n      hashScrollBehavior = props.hashScrollBehavior,\n      hrefProp = props.href,\n      onClickProp = props.onClick,\n      onMouseEnterProp = props.onMouseEnter,\n      prefetch = props.prefetch,\n      state = props.state,\n      _d = props.style,\n      style = _d === void 0 ? {} : _d,\n      rest = __rest(props, [\"active\", \"activeClassName\", \"activeStyle\", \"className\", \"disabled\", \"exact\", \"hashScrollBehavior\", \"href\", \"onClick\", \"onMouseEnter\", \"prefetch\", \"state\", \"style\"]);\n\n  var _e = useLinkProps({\n    hashScrollBehavior: hashScrollBehavior,\n    href: hrefProp,\n    onClick: onClickProp,\n    onMouseEnter: onMouseEnterProp,\n    prefetch: prefetch,\n    state: state\n  }),\n      onClick = _e.onClick,\n      onMouseEnter = _e.onMouseEnter,\n      linkProps = __rest(_e, [\"onClick\", \"onMouseEnter\"]);\n\n  var actualActive = useActive(linkProps.href, {\n    exact: !!exact\n  });\n\n  if (active === undefined) {\n    active = actualActive;\n  }\n\n  return React.createElement(\"a\", __assign({\n    ref: anchorRef,\n    className: className + \" \" + (active ? activeClassName : ''),\n    style: __assign(__assign({}, style), active ? activeStyle : {})\n  }, rest, linkProps, {\n    // Don't handle events on links with a `target` prop.\n    onClick: props.target ? onClickProp : onClick,\n    onMouseEnter: props.target ? onMouseEnterProp : onMouseEnter\n  }));\n});","map":null,"metadata":{},"sourceType":"module"}