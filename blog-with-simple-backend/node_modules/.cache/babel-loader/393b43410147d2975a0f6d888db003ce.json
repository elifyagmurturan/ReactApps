{"ast":null,"code":"import axios from 'axios';\nimport { createContext, useState, useCallback, useContext, useRef, useEffect, useReducer, useMemo } from 'react';\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a),\n        arrB = isArray(b),\n        i,\n        length,\n        key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n    var dateA = a instanceof Date,\n        dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n    var regexpA = a instanceof RegExp,\n        regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n    var keys = keyList(a);\n    length = keys.length;\n    if (length !== keyList(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!hasProp.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a !== a && b !== b;\n};\n\nfunction request(config, // we use 'payload' to enable non-ts applications to leverage type safety and\n// as a argument sugar that allow us to extract the payload type easily\n_payload) {\n  // we also ignore it here, so the payload value won't propagate as a possible\n  // undefined, where its default value is actually `null`.\n  // @ts-ignore\n  return config;\n}\n\nfunction createRequestError(error) {\n  var data = error.response ? error.response.data : null;\n  return {\n    data: data,\n    message: error.message,\n    code: data && data.code || error.code || error.response && error.response.status,\n    isCancel: axios.isCancel(error)\n  };\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nvar RequestContext = createContext(null);\nvar RequestProvider = RequestContext.Provider;\nvar RequestConsumer = RequestContext.Consumer;\n\nvar MissingProviderError =\n/** @class */\nfunction (_super) {\n  __extends(MissingProviderError, _super);\n\n  function MissingProviderError() {\n    return _super.call(this, 'react-request-hook requires an Axios instance to be passed through ' + 'context via the <RequestProvider>') || this;\n  }\n\n  return MissingProviderError;\n}(Error);\n\nfunction useRequest(fn) {\n  var axiosInstance = useContext(RequestContext);\n\n  if (!axiosInstance) {\n    throw new MissingProviderError();\n  }\n\n  var _a = useState([]),\n      sources = _a[0],\n      setSources = _a[1];\n\n  var mountedRef = useRef(true);\n\n  var removeCancelToken = function removeCancelToken(cancelToken) {\n    if (mountedRef.current) {\n      setSources(function (prevSources) {\n        return prevSources.filter(function (source) {\n          return source.token !== cancelToken;\n        });\n      });\n    }\n  };\n\n  var callFn = useRef(fn);\n  useEffect(function () {\n    callFn.current = fn;\n  }, [fn]);\n  var request$$1 = useCallback(function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var config = callFn.current.apply(callFn, args);\n    var source = axios.CancelToken.source();\n\n    var ready = function ready() {\n      setSources(function (prevSources) {\n        return prevSources.concat([source]);\n      });\n      return axiosInstance(_assign({}, config, {\n        cancelToken: source.token\n      })).then(function (response) {\n        removeCancelToken(source.token);\n        return response.data;\n      }).catch(function (error) {\n        removeCancelToken(source.token);\n        throw createRequestError(error);\n      });\n    };\n\n    return {\n      ready: ready,\n      cancel: source.cancel\n    };\n  }, [axiosInstance]);\n  var clear = useCallback(function (message) {\n    if (sources.length > 0) {\n      sources.map(function (source) {\n        return source.cancel(message);\n      });\n      /* istanbul ignore next */\n\n      if (mountedRef.current) {\n        setSources([]);\n      }\n    }\n  }, [sources]);\n  var clearRef = useRef(clear);\n  useEffect(function () {\n    clearRef.current = clear;\n  });\n  useEffect(function () {\n    return function () {\n      clearRef.current();\n      mountedRef.current = false;\n    };\n  }, []);\n  return [{\n    clear: function clear(message) {\n      return clearRef.current(message);\n    },\n    hasPending: sources.length > 0\n  }, request$$1];\n}\n\nvar REQUEST_CLEAR_MESSAGE = 'A new request has been made before completing the last one';\n\nfunction getNextState(state, action) {\n  return {\n    data: action.type === 'success' ? action.data : state.data,\n    error: action.type === 'error' ? action.error : undefined,\n    isLoading: action.type === 'start' ? true : false\n  };\n}\n\nfunction useResource(fn, defaultParams) {\n  var _a = useRequest(fn),\n      clear = _a[0].clear,\n      createRequest = _a[1];\n\n  var _b = useReducer(getNextState, {\n    isLoading: Boolean(defaultParams)\n  }),\n      state = _b[0],\n      dispatch = _b[1];\n\n  var _c = useState(defaultParams),\n      requestParams = _c[0],\n      setRequestParams = _c[1];\n\n  var request = useCallback(function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    clear(REQUEST_CLEAR_MESSAGE);\n\n    var _a = createRequest.apply(void 0, args),\n        ready = _a.ready,\n        cancel = _a.cancel;\n\n    (function flow() {\n      return __awaiter(this, void 0, void 0, function () {\n        var data, error_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              dispatch({\n                type: 'start'\n              });\n              return [4\n              /*yield*/\n              , ready()];\n\n            case 1:\n              data = _a.sent();\n              dispatch({\n                type: 'success',\n                data: data\n              });\n              return [3\n              /*break*/\n              , 3];\n\n            case 2:\n              error_1 = _a.sent();\n              if (!error_1.isCancel) dispatch({\n                type: 'error',\n                error: error_1\n              });\n              return [3\n              /*break*/\n              , 3];\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    })();\n\n    return cancel;\n  }, [createRequest]);\n  useEffect(function () {\n    // The array of default request params is a dependency that we pass directly\n    // as a dependency to this useEffect, which will run on the initial render\n    // and subsequent params updates, triggering new requests as the params change.\n    // If the dependency is not set, we avoid going down this road. Hooks should be\n    // either fully controlled or self-contained.\n    if (!defaultParams) return; // We perform an deep equality check of the params and rely on React's bail out\n    // to control future request calls made passing default params as dependency\n\n    setRequestParams(function (current) {\n      return fastDeepEqual(current, defaultParams) ? current : defaultParams;\n    });\n  }, defaultParams);\n  useEffect(function () {\n    var canceller = function canceller() {};\n\n    if (requestParams) {\n      canceller = request.apply(void 0, requestParams);\n    }\n\n    return canceller;\n  }, [requestParams]);\n  return useMemo(function () {\n    var cancel = function cancel(message) {\n      dispatch({\n        type: 'reset'\n      });\n      clear(message);\n    };\n\n    var result = [_assign({}, state, {\n      cancel: cancel\n    }), request];\n    return result;\n  }, [state, request]);\n}\n\nexport { fastDeepEqual as isEqual, request, createRequestError, useRequest, useResource, RequestContext, RequestProvider, RequestConsumer };","map":null,"metadata":{},"sourceType":"module"}